# [0014. KMP 算法](https://github.com/tnotesjs/TNotes.algorithms/tree/main/notes/0014.%20KMP%20%E7%AE%97%E6%B3%95)

<!-- region:toc -->

::: details 📚 相关资源

- [📒 TNotes（相关知识库）](https://tnotesjs.github.io/TNotes/)
  - [TNotes.leetcode/notes/0028](https://tnotesjs.github.io/TNotes.leetcode/notes/0028/)

:::

- [1. 🎯 本节内容](#1--本节内容)
- [2. 🫧 评价](#2--评价)
- [3. 🤔 KMP 是什么？](#3--kmp-是什么)
- [4. 🤔 KMP 算法的基本思想是什么？](#4--kmp-算法的基本思想是什么)
- [5. 🔍 相关 LeetCode 例题](#5--相关-leetcode-例题)

<!-- endregion:toc -->

## 1. 🎯 本节内容

- todo

## 2. 🫧 评价

- todo

## 3. 🤔 KMP 是什么？

KMP（Knuth-Morris-Pratt）算法是一种高效的字符串匹配算法，由 Donald Knuth、Vaughan Pratt 和 James H. Morris 独立发明，并于 1977 年发表。这种算法的主要优点在于它能够在线性时间内完成模式串在文本串中的查找，即其时间复杂度为 O(n+m)，其中 n 是文本串的长度，m 是模式串的长度。

- 文本串 - 待匹配的字符串，也称为主串（haystack）。
- 模式串 - 要在文本串中查找的字符串，也称为子串（needle）。

KMP 算法因其高效性和实用性，在文本处理、搜索引擎等领域有着广泛的应用。通过预处理模式串，KMP 能够在最坏情况下也能保证线性时间复杂度，这使得它成为解决字符串匹配问题的一个非常优秀的算法。

## 4. 🤔 KMP 算法的基本思想是什么？

KMP 算法的核心在于利用已经匹配过的信息，避免从头开始重新匹配。当模式串的一个位置与主串不匹配时，KMP 算法可以知道之前已经匹配过的字符信息，并据此决定模式串应该移动的位置，而不是简单地将模式串向后移动一位。

KMP 算法的关键组件【关键在于理解匹配过程】

1. 部分匹配表（Partial Match Table, PMT），也称为“next 数组”：
   - 这是一个数组，用于存储模式串中每个前缀的最大相同前后缀的长度。
   - 例如，对于模式串 "ABCDABD"，其 PMT（或 next 数组）可能是 [0, 0, 0, 0, 1, 2, 0]。这意味着，如果在模式串的第 `j` 个位置失配，那么模式串应该回退到 `next[j - 1]` 的位置继续匹配。
     - 具体来说，假设匹配到 ABCDAB D 加粗的 D 位置时候出现了失配的情况，此时 j 为 6，这时候就需要让 j 回退，如果暴力处理的话，一旦出现了失配的情况，那么直接将 j 回退到开头 0 的位置，一切都从头开始。但是 next 可以对回退的逻辑进行优化，此时只需要回退到 `next[j - 1]` 的位置（也就是 `next[6 - 1] => 2`）即可，表示下次匹配的位置是 AB C DABD 中索引为 2 的位置，也就是加粗的 C 的位置开始，这是因为 AB CDABD 和 ABCD AB D 子串 AB 相同，虽然 D 位置出现了失配，但是没必要回退到开头，D 前边的 AB 子串和开始位置开始的 AB 是相同的，下次直接从 C 开始即可。
   - PMT 的构建是 KMP 算法中较为复杂的部分，但一旦构建好，就能大大提高匹配效率。
2. 匹配过程：
   - 在匹配过程中，KMP 算法使用两个指针，一个指向主串（haystack），另一个指向模式串（needle）。
   - 当发生失配时，模式串指针不会回溯到起始位置，而是根据 PMT 移动到下一个可能匹配的位置。
   - 如果模式串完全匹配，则返回匹配的起始位置；否则，继续匹配直到主串结束或找到匹配。

## 5. 🔍 相关 LeetCode 例题

- [28. 实现 strStr()](https://leetcode.cn/problems/implement-strstr/)
